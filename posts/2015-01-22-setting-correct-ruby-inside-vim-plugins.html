
<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <title>Configurando ruby correto dentro de plugins do vim - wevtimoteo</title>
    <link rel="stylesheet" href="/assets/css/style.css">
    <link rel="stylesheet" href="/assets/css/prism.css">
  </head>
  <body>
    <div id="wrapper">
      <header id="top">
        <h1><a href="/">wevtimoteo</a></h1>
        <p>kairos _ sharing _ tech _ learning _ kaizen _ path</p>
      </header>
      <nav>
<ul>
  <li><a href="/posts">Posts</a></li>
  <li><a href="/about.html">About</a></li>
</ul>
</nav>
      <hr>
      <main><article class="post"><header><h1 id="configurando-ruby-correto-dentro-de-plugins-do-vim">Configurando ruby correto dentro de plugins do vim</h1><p>
      Monday, 6 Oct 2014
      
        <span class="tags">
          Tags:
          
            <a class="tag" href="/tags/ruby">ruby</a><a class="tag" href="/tags/vim">vim</a><a class="tag" href="/tags/vim plugins">vim plugins</a></span></p></header><div><p>Primeiro post de 2015 e primeiro post na plataforma Pelican depois da migração do <a href="http://octopress.org/">Octopress</a> para o <a href="http://blog.getpelican.com/">Pelican</a>. Depois escrevo sobre como foi essa migração.</p><p>Já tinha lido muitos artigos a respeito de <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity">Cyclomatic Complexity</a>, mas nunca tentei colocar algum script para avaliar meu código.</p><p>Antes tarde que nunca, encontrei o plugin <a href="https://github.com/fousa/vim-flog">vim-flog</a> que é um fork do <a href="https://github.com/skammer/vim-ruby-complexity">vim-ruby-complexity</a>; que como o nome já diz, serve para avaliar a Complexidade Ciclomática dentro de scripts .rb.</p><p>Acontece que esse plugin executa código ruby dentro do arquivo <code class="inline">.vim</code> (caso queira saber mais: <a href="http://mattmargolis.net/scripting_vim_with_ruby.pdf">Scripting Vim with Ruby</a>).</p><p>Até então, isso não deveria ser um problema. Acontece que quando o script rodava:</p><pre><code class="ruby">ruby &lt;&lt; EOF

require &apos;rubygems&apos;
require &apos;flog&apos;

class Flog</code></pre><p>Ocorria um erro na linha <code class="inline">require &apos;flog&apos;</code> que não encontrava a <code class="inline">gem</code>, apesar de eu já ter instalado no meu <code class="inline">ruby</code> local usando <code class="inline">gem install flog</code>.</p><p>Tentei entender o problema olhando o <code class="inline">$GEM_PATH</code>, <code class="inline">$GEM_ROOT</code> e <code class="inline">$GEM_HOME</code> dentro do código do plugin, no entanto, ambos estavam vazios.</p><p>Parti para outro caminho e olhei o path do ruby executado adicionando:</p><pre><code class="ruby">puts $:

require &apos;rubygems&apos;
require &apos;flog&apos;</code></pre><p>O <code class="inline">$:</code> serve para imprimir o path de onde o <code class="inline">ruby</code> é procurado (tente rodar isso dentro do <code class="inline">irb</code>).</p><p>Nesse comando, percebi que o <code class="inline">ruby</code> que estava sendo executado era o que vem juntamente do OS X Yosemite (2.x) e não o meu <code class="inline">ruby</code> do <code class="inline">rbenv</code> (alternativa ao <code class="inline">rvm</code>).</p><p>Como eu sempre fiz upgrade nos releases do <code class="inline">OS X</code> e nunca um clean install.
Achei um report do bug no <a href="https://github.com/dotphiles/dotzsh#mac-os-x">path_helper</a>, para resolver isso, basta:</p><pre><code class="">sudo chmod ugo-x /usr/libexec/path_helper</code></pre><p>Segue trecho do link acima caso o link se torne obsoleto:</p><pre><code class="">path_helper is intended to make it easier for installers to add new paths to the environment without having to edit shell configuration files by adding a file with a path to the /etc/paths.d directory.

Unfortunately, path_helper always reads paths from /etc/paths set by Apple then paths from /etc/paths.d set by third party installers, and lastly paths from the PATH environment variable set by the parent process, which ultimately is set by the user with export PATH=... Thus, it reorders path priorities, and user /bin directories meant to override system /bin directories end up at the tail of the array.</code></pre></div></article></main>
      <hr>
      <footer>
        
<!--=====================================-->
<!-- Override "includes/footer.html.eex" -->
<!-- to customize your footer contents.  -->
<!--=====================================-->

        <p>
          Powered by <a href="https://github.com/Dalgona/Serum">Serum</a> v1.1.0,
          with <a href="https://github.com/Dalgona/serum-theme-essence">Essence</a> theme
        </p>
      </footer>
    </div>
    <script src="/assets/js/prism.js"></script>
  </body>
</html>
<script>
const ws_url = "ws://" + location.host + "/serum_live_reloader";
var ws;

connect();

function connect() {
  ws = new WebSocket(ws_url);
  ws.onmessage = onMessage;
  ws.onclose = onClose;
}

function onMessage(e) {
  if (e.data === "reload") {
    location.reload();
  }
}

function onClose(e) {
  console.warn("WebSocket disconnected from server. Reconnecting in 10 seconds.");
  setTimeout(connect, 10000)
}
</script>
