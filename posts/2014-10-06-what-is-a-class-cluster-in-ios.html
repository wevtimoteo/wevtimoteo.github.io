
<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

    <link rel="shortcut icon" href="assets/images/favicon.ico" type="image/x-icon">
    <link rel="icon" href="assets/images/favicon.ico" type="image/x-icon">

    <title>O que significa 'Class Cluster' no iOS - wevtimoteo</title>

    <link rel="stylesheet" href="/assets/css/style.css">
    <link rel="stylesheet" href="/assets/css/prism.css">
  </head>
  <body>
    <div id="wrapper">
      <header id="top">
        <h1><a href="/">wevtimoteo</a></h1>
        <p>kairos _ sharing _ tech _ learning _ kaizen _ path</p>
      </header>

      <nav>
<ul>
  <li><a href="/posts">Posts</a></li>
  <li><a href="/about.html">About</a></li>
</ul>
</nav>

      <hr />

      <main>
        
<h1>O que significa 'Class Cluster' no iOS</h1>

<em>Posted on Monday, 6 Oct 2014</em>

<p><code class="inline">Class Cluster</code> é um design pattern usado no framework Foundation.</p>
<p>O objetivo desse pattern é agrupar subclasses privadas a partir de uma superclasse pública abstrata.</p>
<h2>Sem Class Cluster</h2>
<p>Imagine o seguinte cenário: você precisa armazenar diversas medidas, milímetros, centímetros, metros, quilômetros.</p>
<p>O que todas essas medidas possuem em comum? Elas podem ser convertidas (ex.: metros =&gt; centímetros) e podem ser representadas por uma única classe.
No entanto, o armazenamento de cada uma delas pode ser diferente.</p>
<p>Para lidar com este cenário poderíamos implementar da seguinte maneira:</p>
<ul>
<li><p>Comprimento (superclasse)</p>
<ul>
<li>Milímetro
</li>
<li>Centímetro
</li>
<li>Metro
</li>
<li>Quilômetro
</li>
</ul>
</li>
</ul>
<p><code class="inline">Comprimento</code> é nossa superclasse que declara os métodos principais de operações que todas as outras subclasses terão em comum.</p>
<p>Neste exemplo as subclasses são públicas, ou seja, você pode instanciá-las diretamente.</p>
<p>O conceito é simples mas a interface começa a ficar complexa de acordo com a quantidade de subclasses.</p>
<h2>Com Class Cluster</h2>
<p>Com o mesmo cenário, vamos imaginar uma solução diferente: ao invés das subclasses públicas teremos apenas nossa superclasse pública. E como iremos instanciar uma subclasse irá depender do que nossa superclasse <code class="inline">Comprimento</code> suporta.</p>
<p>Agora é responsabilidade da superclasse dizer qual objeto deve ser criado a partir do método de classe que for chamado.</p>
<p>Exemplo:</p>
<p><code class="inline">WWLength *aMeter = [WWLength lengthWithMeter:1];</code></p>
<p>Cada objeto retornado pelo seu método de factory pode pertencer a um tipo de instância da subclasse. Mas não se esqueça, neste caso a subclasse está oculta, você não a conhece, então nossa instância <code class="inline">aMeter</code> é do tipo <code class="inline">WWLength</code>.</p>
<p>Esse é o conceito do Class Cluster, que é utilizado intensamente no framework Foundation.</p>
<p>Dê uma olhada na documentação para obter mais informações de classes do Foundation que seguem esta abordagem: <a href="https://developer.apple.com/library/ios/documentation/general/conceptual/DevPedia-CocoaCore/ClassCluster.html">Cocoa Core Class Cluters</a></p>



  <h3>Tags</h3>

  <ul>
    
      <li><a href="/tags/class cluster">class cluster</a></li>
    
      <li><a href="/tags/design pattern">design pattern</a></li>
    
      <li><a href="/tags/foundation">foundation</a></li>
    
      <li><a href="/tags/ios">ios</a></li>
    
      <li><a href="/tags/objective-c">objective-c</a></li>
    
  </ul>


      </main>

      <hr />

      <footer>
        
        <p>
          Copyright &copy; 2019 <a href="https://github.com/wevtimoteo">Weverton Timoteo</a>

          <span class="engine-credits">This website was generated by <a href="https://github.com/Dalgona/Serum">Serum</a></span>
        </p>
      </footer>
    </div>
    <script src="/assets/js/prism.js"></script>
  </body>
</html>
<script>
const ws_url = "ws://" + location.host + "/serum_live_reloader";
var ws;

connect();

function connect() {
  ws = new WebSocket(ws_url);
  ws.onmessage = onMessage;
  ws.onclose = onClose;
}

function onMessage(e) {
  if (e.data === "reload") {
    location.reload();
  }
}

function onClose(e) {
  console.warn("WebSocket disconnected from server. Reconnecting in 10 seconds.");
  setTimeout(connect, 10000)
}
</script>
